Tautan Adaptable:
https://inventorybeta.adaptable.app/

TUGAS 2
1. Pertama-tama, kita harus membuat proyek dimana app kita yang bernama main berada. Dalam hal ini, saya menamai proyek sata sebagai InventoryBeta dan kemudian saya hubungkan ke repository github. Setelah tercipta project nya, kita jalankan startapp main untuk membuat app bernama main. Jangan lupa, kita harus menambahkan main pada INSTALLED APPS yang ada di settings.py proyek InventoryBeta. Hal ini bertujuan agar Django mengenali bahwa main merupakan app yang bisa dijalankan. Setelah itu, kita isi models.py dengan Class Item dan atribut-atributnya sesuai yang di ketentuan. Setelah model selesai dibuat, saya terlebih dahulu membuat folder template serta membuat file home.html, agar ketika membuat fungsi di views.py, kita sudah tau file html mana yang mau ditampilkan. Setelah membuat file html nya, saya membuat fungsi home yang digunakan untuk me-render file home.html yang nantinya akan digunakan untuk menampilkan data model kita. Setelah menyelesaikan views, kita isi urls.py yang ada di InventoryBeta supaya kita bisa mengatur rute url agar spesifik ke aplikasi main kita. Disini saya men-setting, jika url nya string kosong, maka langsung jalankan url milik app main agar tidak perlu memasukkan /main lagi. Barulah setelah itu kita mengisi urls.py yang ada di main. Saya setting agar jika kita memasukkan url kosong, maka jalankan fungsi home yang ada di views.py agar secara default, app main akan menampilkan home.html yang adalah tampilan data kita. Terakhir, kita tinggal commit dan push ke github, setelah itu deploy ke Adaptable. Saya juga menambahkan test case untuk model dimana isinya adalah mengecek apakah field dan atribut model Item kita yang diinput dan yang tersimpan sudah benar, serta apakah field name nya sudah sesuai maksimal karakter yang diberikan. 

2. !(Screenshot (1263).png)

3. Virtual environment berfungsi supaya aplikasi dan segala hal yang berhubungan dengan proyek django kita tidak bentrok dengan python dan django versi lainnya yang mungkin saja terinstall di komputer kita yang mungkin saja bisa menyebabkan masalah. Kita bisa saja tidak menggunakan virtual environment untuk project django, tetapi seperti poin diatas, bisa menyebabkan bentrok dengan python atau django versi lain yang terinstall di komputer.

4.
MVT adalah Model View Template, yaitu suatu arsitektur untuk menampilkan web, aplikasi, atau    User Interface lain. Perbedaannya dengan MVC adalah di bagian Template. Template disini adalah kode HTML yang akan befungsi untuk menampilkan respons dari request HTTP client. Model dan View pada MVT akan di-manage atau dijembatani oleh framework.

MVC adalah Model View Controller. Pada MVC, Controller akan berfungsi sebagai jembatan bagi
Model dan View. Controller ini yang akan memerintahkan Model untuk meng-update kondisinya jika ada perubahan serta memerintahkan View untuk menampilkan ke user ataupun mengubah tampilannya jika ada perubahan juga. Hal ini berbeda dengan MVT dimana Template lah yang akan memberikan tampilan ke Client, sementara yang menjadi jembatan antara Model dan View adalah framework.

MVVM adalah Model-View-ViewModel. Pada MVVM, yang menjadi jembatan antar Model dan View adalah Model-View. Model-View ini merupakan tempat dimana function, command, serta method dituliskan untuk membantu menampilkan isi dan kondisi dari View, sekaligus menjadi tempat pengoperasian model kita. Hal ini berbeda dengan MVT yang menggunakan framework, atau MVC yang menggunakan Controller


TUGAS 2
1. Untuk POST, nama variabel atau value nya tidak ditampilkan di url sehingga relatif lebih aman, serta tidak ada batas panjang value karakter yang ingin diberikan. Untuk GET, nama variabel atau value akan ditampilkan di url serta batas panjang value yang akan diberikan adalah 255 karakter. POST juga men-support berbagai jenis data seperti String, Integer, Binary, dll, sedangkan GET hanya support String.

2. HTML digunakan untuk menampilkan data dalam bentuk yang interaktif, menarik, serta enak untuk dilihat oleh orang secara umum. XML dan JSON digunakan untuk menyimpan dan mentransmisikan data antar app. Perbedaan antar XML dan JSON adalah di bagian tampilan kode nya. XML akan menyimpan data dalam bentuk tag, mirip seperti kode pada HTML. JSON akan menyimpan objek data dalam bentuk teks yang mudah untuk dibaca. Objek pada JSON akan disimpan dalam bentuk key dan value, mirip seperti dictionary pada python.

3. Alasan utamanya adalah, format JSON adalah bentuk teks, sehingga kode untuk membaca dan membuat JSON banyak tersedia di berbagai bahasa pemrograman. Selain sifatnya yang universal karena dapat dioperasikan di banyak bahasa pemrograman, isi dari file JSON juga mudah untuk dibaca oleh manusia karena tidak serumit XML. 

4. Pertama-tama, kita buat dulu file forms.py yang akan kita gunakan sebagai struktur form untuk menginput item baru. Pada file tersebut, kita buat class bernama ItemForm sebagai class form khusus untuk model class Item. Selanjutnya kita buat file html bernama create_product.html, dimana file tersebut akan menampilkan parameter model Item kita, sebuah box kosong untuk mengisi parameter tersebut, serta tombol submit untuk menyimpan item yang dia buat. Setelah file untuk menampilkan form nya jadi, kita tambahkan fungsi create_product pada views.py yang nantinya akan bertugas untuk me-render create_product.html, memvalidasi input dari form tadi, serta menyimpan data dari form tersebut. Kemudian untuk mengerjakan bonus,  saya memanfaatkan Item.objects.count, dimana method ini akan menampilkan berapa banyak objek dari model Item yang tersimpan di app kita. Dan juga karena setiap objek punya amount, saya memanfaatkan Item.objects.all yang dimana method ini akan me return seluruh objek dari model Item yang tersimpan, kemudian kita iterasikan seluruh objek yang ada di sana dan ambil value dari parameter 'amount' yang ada di masing-masing objek untuk mendapatkan total amount dari seluruh objek Item yang ada. Kemudian kita tambahkan button di home.html, yang mana jika button tersebut ditekan, user akan otomatis di direct ke url 'create_product/' untuk mengisi form. Tak lupa juga saya tambahkan jumlah item serta total amount ke home.html juga. Selanjutnya kita setting urls.py yang ada di folder main, supaya jika kita memasukkan url 'create_product/', ia akan menjalankan fungsi create_product yang ada di views.py supaya menampilkan halaman pengisian form. Selanjutnya kita membuat fungsi show_xml pada views.py, kita ambil seluruh objek Item yang tersimpan dengan cara Item.objects.all dan kita manfaatkan method serializer untuk mentranslate objek-objek Item yang tersimpan di data kita menjadi bentuk file xml. Hal yang sama juga kita lakukan untuk file JSON. Kita buat fungsi show_json dan kita gunakan method serializer untuk mentranslate objek yang tersimpan menjadi bentuk file JSON. Kemudian kita setting lagi ke urls.py, jika kita memasukkan url 'xml/', app akan memanggil method show_xml untuk menampilkan file xml kita, tak lupa juga jika kita memasukkan url 'json', app akan menampilkan file JSON. Kemudian kita juga ingin menampilkan file XML dan JSON tetapi hanya untuk objek dengan id tertentu. Kita bisa buat method show_xml_by_id serta show_json_by_id dan manfaatkan method objects.filter(pk) dan kembali gunakan serializer untuk mentranslate nya menjadi bentuk xml dan json. Perbedaan dengan show_xml atau show_json hanyalah di bagian Item.objects.all yang mana method tersebut akan mereturn semua objek Item yang tersimpan, sedangkan Item.objects.filter(pk) hanya akan me return objek Item dengan id yang kita inginkan saja. Terakhir, kita kembali tambahkan url 'xml/<int:id>/' dan url 'json/<int:id>/ agar jika kita memasukkan url tersebut, app secara otomatis akan menampilkan file xml atau json dari id yang kita inginkan.

5. 
![SS HTML part 1](ss_home_html_part1.png)
![SS HTML part 2](ss_home_html_part2.png)
![SS xml](ss_xml.png)
![SS json](ss_json.png)
![SS xml id 1](ss_xml_id_1.png)
![SS json id 1](ss_json_id_1.png)

TUGAS 4

1. Django UserCreationForm merupakan form build in dari django yang langsung memungkinkan kita membuat user dengan memasukkan username dan password tanpa perlu menulis kode form dari awal lagi. Keuntungannya tentu saja kita hanya perlu import form tersebut saja dan langsung bisa kita pakai, tidak perlu membuat object form lagi kemudian kita tulis sedemikian rupa supaya bisa menyimpan username dan password. Kekurangannya adalah UserCreationForm hanya bisa digunakan untuk menyimpan username dan password, kita tidak bisa menyimpan email untuk verifikasi, ataupun nomor telepon

2. Otentikasi adalah mem-verify siapa user yang berusaha login. Biasanya dengan mengecek apakah username yang diinput ada, jika ada, dicek lagi apakah password yang diinput itu benar milik username yang bersangkutan. Otorisasi adalah mengecek apa saja yang bisa dan tidak bisa dilakukan oleh orang yang berhasil di otentikasi. Misalnya user umum hanya bisa mengakses bagian tertentu dari website dan kemampuan yang bisa dilakukan terbatas, berbeda dengan admin yang lebih leluasa. Keduanya penting untuk menjaga agar website senantiasa terkontrol dengan membatasi siapa saja yang bisa masuk dan apa saja yang bisa dan tidak bisa dilakukan oleh user yang masuk

3. Cookies merupakan informasi atau data yang akan disimpan di browser milik user/client. Ketika web server berinteraksi dengan banyak web browser, web server perlu mengidentifikasi request mana yang datang dari web browser mana. 

4. Cookies bisa saja diretas dan diambil informasi-informasi yang tersimpan disana, khususnya jika cookies sehabis dari login suatu akun. Jika cookies tidak dihapus secara berkala, bisa saja menumpuk di memori dan mengurangi performan, khususnya pada device yang tua

5.
Pertama-tama kita membuat fungsi untuk register yang bertugas untuk membuat user baru dengan memanfaatkan UserCreationForm dan buat juga file register.html. Fungsi register tersebut akan meminta input username dan password, dan akan menyimpan user yang baru jika username yang diinput belum ada yang pernah pakai. Fungsi tersebut juga akan menampilkan pesan "
Pertama-tama kita membuat fungsi untuk register yang bertugas untuk membuat user baru dengan memanfaatkan UserCreationForm dan buat juga file register.html. Fungsi register tersebut akan meminta input username dan password, dan akan menyimpan user yang baru jika username yang diinput belum ada yang pernah pakai. Fungsi tersebut juga akan menampilkan pesan "Your account has been successfully created!" apabila kita berhasil menyimpan user baru. Fungsi tersebut kemudian kita render ke file register.html yang tadi kita buat, akan form nya bisa ditampilkan. Tak lupa kita tambahkan path "register/" di urls.py agar bisa men-direct ke halaman register. Kemudian kita buat fungsi login dan juga file login.html. Method login tersebut akan meminta input username dan password kemudian melakukan otentikasi user. Jika berhasil, maka program akan men-direct ke halaman utama, jika tidak, maka akan menampilkan 'Sorry, incorrect username or password. Please try again.'. Kemudian, fungsi login tersebut kita render ke file login.html yang tadi dibuat supaya bisa menampilkan halaman login. Di file login.html juga kita buat button yang akan men-direct ke halaman register jika user belum punya akun. Tak lupa juga kita harus menambahkan path "login/" di urls.py. Selanjutnya kita juga buat fungsi logout yang akan bertugas menghapus sesi login pengguna yang saat ini masuk, kemudian akan men-direct kembali ke halaman login. Jangan lupa kita tambahkan path(logout/) supaya kita bisa mengakses url fungsi logout. Terakhir tinggal kita buat button di file home.html yang akan men direct ke fungsi logout jika diklik. Kemudian kita juga akan me restriksi halaman home dengan @login_required(login_url='/login') yang akan mengharuskan user untuk logim terlebih dahulu sebelum masuk ke halaman utama. Kemudian kita juga bisa mengimplementasikan cookie untuk memanfaatkan session id kita seperti kita login jam berapa, dan username siapa yang sedang login. Untuk menampilkan last login kita, kita bisa set cookie di fungsi login dengan nama last_login yang isinya adalah string datetime.datetime.now() yang akan menampilkan pukul berapa kita terakhir kali melakukan login. kemudian untuk menampilkannya di halaman utama, kita tinggal tambahkan saja 'last_login': request.COOKIES['last_login'] di fungsi home kita. Kemudian kita juga set agar setiap logout, kita akan menghapus cookie login kita dengan menggunakan response.delete_cookie('last_login'). Kemudian kita bisa menampilkan value dari last_login di home.html yang isinya adalah waktu terakhir kita login. Terakhir kita akan mengasosiasikan user dengan model yang sudah dibuatnya, agar setiap user hanya bisa melihat model yang ia buat sendiri. Kita tambahkan field user pada models.py dan kita isi dengan models.ForeignKey, hal tersebut untuk mengasosiasikan suatu model dengan user tertentu. Kemudian kita tambahkan product = form.save(commit=False) yang bertujuan agar django tidak langsung menyimpan objek yang dibuat dari form ke database supaya kita bisa mendapatkan username dari yang membuat objek tersebut. Kemudian tinggal tambahkan username yang bersangkutan ke home.html. Langkah terakhir tinggal lakukan migrate supaya perubahan yang kita buat pada models.py tersimpan. Kemudian untuk menambahkan amount dari object Item sebanyak 1, kita membuat fungsi yang akan menerima id objek sebagai parameter, disini fungsitersebut saya namakan increement_amount , kemudian kita gunakan Item.objects.get(pk=id) untuk mendapatkan objek dengan id tersebut dan assign ke variabel dengan nama updated_item. Kemudian kita gunakan updated_item.amount += 1 yang akan menambahkan value dari amount pada objek tersebut sebanyak 1 kemudian kita save dengan menjalankan updated_item.save(), dan terakhir kita jalankan HttpResponseRedirect(reverse('main:home')) yang akan langsung me-redirect kembali ke halaman secara real time (tak perlu refresh) dan langsung meng-update amount yang baru. Kemudian kita tambahkan path(increement_amount<int:id>/) supaya kita bisa assign url fungsi tadi ke suatu button. Terakhir tinggal tambahkan saja button yang jika diklik akan memanggil url tadi beserta id objek yang dia reference. Hal yang sama berlaku untuk mengurangi amount, kita buat fungsi yang menerima objek id sebagai parameter, fungsi yang saya buat bernama decreement_amount, tetapi untuk decreement saya tambahkan kondisi jika amount suatu objek sudah 0, dia tidak akan menguranginya lagi melainkan akan menampilkan error message bahwa amount sudah 0, jika amount > 0 barulah dia akan mengurangi. Setelah mengurangi amount kita save juga kemudian kembali direct ke halaman home. Tak lupa juga tambahkan path(decreement_amount<int:id>/) dan assign url tersebut ke button. Kemudian untuk delete item juga sama saja seperti tadi, kita buat fungsi yang menerima objek id, saya namakan delete_item. Kemudian ambil objeknya dengan Item.objects.get(pk=id) dan saya simpan ke variable deleted_item. Kemudian tinggal jalanakan deleted_item.delete() untuk menghapus item tersebut, kemudian kita direct kembali ke halaman home. Tak lupa tambahkan path('delete_item/<int:id>') dan assign url tersebut ke button

TUGAS 5
1.
Tag selector, digunakan untuk mengubah properti dari suatu elemen dengan tag yang sama. Berguna apabila misalkan kita ingin menulis suatu text yang format atau style nya disesuaikan untuk masing-masing tag, misalkan kita ingin membedakan style dari judul, isi paragraf, dsb. 

Class Selector, digunakan untuk memilih elemen berdasarkan nama class yang kita berikan. Berguna apabila kita inign mengelompokkan suatu elemen dengan karakteristik yang sama

ID Selector, mirip seperti Class Selector, tetapi ID Selector hanya bisa digunakan oleh satu elemen saja. Digunakan apabila kita ingin format yang spesifik pada suatu elemen yang speisfik pula pada web kita

Attribute Selector, selector ini akan memilih elemen berdasarkan atribut yang sama. Berguna apabila kita ingin menyeleksi suatu elemen berdarkan atribut yang dimilikinya agar tampilan antar elemen mudah untuk dibedakan

Universal Selector, digunakan untuk menyeleksi semua elemen yang ada pada scope tertentu. Biasanya digunakna apabila kita ingin me-reset suatu margin atau padding

Pseudo Selector, digunakan untuk memilih elemen yang sifatnya semu, Terdapat dua macam Pesudo Selector, yaitu PSeudo Class dan Pseudo Element. Pseudo Class digunakan untuk memilih state pada elemen, seperti tampilan suatu elemen ketika di klik. Pseudo Element digunakan untuk memilih elemen semu, seperti misal kita ingin meng-edit baris pertama saja dari suatu paragraf, kita bisa gunakan pseudo element.

2.
tag <a></a>, tag untuk menyisipkan hyperlink
tag <b></b>, tag untuk membuat tulisan yang di dalam tag tersebut menjadi cetak tebal
tag <button> untuk menyisipkan tombol
tag <div> untuk men-define suatu division atau section pada file html
tag <form> untuk men-generate form untuk user input
tag <head> untuk menunjukkan head dari stau file html
<table> untuk menyisipkan tabel
<th> untuk membuat header dari cell table
<tr> untuk membuat row 
<td> untuk membuat isi dari cell-cell tabel

3.
Margin merupakan sisi area transparan yang ada di luar border elemen, ia biasa digunakan untuk mengatur jarak antar elemen yang berbeda atau mengatur posisi elemen dari suatu tampilan web. Padding merupakan sisi area transparan yang ada di dalam border elemen. Ia biasa digunakan untuk mengatur posisi suatu text atau hal lain yang ada di dalam suatu elemen

4.
Perbedaan utamanya adalah, komponen-komponen yang ada pada Bootstrap sudah didefinisikan sehingga tampilannya sudah jadi dan dapat langsung digunakan. Sedangkan Tailwind tidak memuat komponen yang siap pakai, hanya memuat kelas-kelas ultilitas yang ada sehingga user harus mendefinisikan dan menggabungkan kelas-kelas ultilitas tersebut untuk menjadi suatu komponen dan tampilan. Ukuran Bootsrap juga lebih besar karena sudah memuat banyak komponen-komponen yang siap pakai. Ukuran Tailwind lebih kecil karena hanya memuat kelas ultilitas saja. Tailwind dapat digunakan apabila kita ingin membuat suatu web yang sangat unik karena komponen dan tampilan Tailwind kita sendiri yang mendefinisikannya sehingga kustomisasi dan fleksibilitasnya bisa lebih baik dari bootstrap yang komponennya terbatas pada apa yang sudah didefinisikan. Di sisi lain, Bootstrap jelas penggunaanya lebih mudah dibanding Tailwind karena semua komponennya sudah siap pakai, sehingga jika kita adalah seorang beginner (seperti saya) dalam membuat web, atau kita tidak ingin kostumisasi yang sangat-sangat unique sekali, Bootstrap akan lebih mudah untuk digunakan.

5.
Untuk memperbagus tampilan website, kita perlu perlu menambahkan bootstrap dan CSS dengan mmog copy link yang diberikan pada tutorial ke base.html. Setelah itu kita tambahkan navbar dengan memanfaatkan komponen nav yang dimiliki bootstrap dan tambahkan nilai dari username kita ke sana serta tambahakan tulisan logout, tak lupa juga pindahkan link yang akan merujuk ke perintah logout ke tulisan logout yang kita buat di nav tadi.

TUGAS 6
1. Asynchronus programming dapat menjalankan lebih dari satu tugas atau kode pada waktu yang bersamaan. Hal ini dapat terjadi karena setiap perintah tidak saling terikat dengan perintah lain oleh urutan, sehingga perintah kedua dapat dijalankan tanpa harus menunggu perintah yang pertama selesai. Sedangkan pada Synchronus programming, perintah sellau dijalankan secara berurutan karena jika kita ingin menjalankan perintah kedua, kita harus menunggu perintah yang pertama selesai dilakukan

2. Event driven programming berarti flow atau jalannnya suatu program akan bergantung pada event atau peristiwa apa yang terjadi, atau bisa juga dikatakan bahwa kode atau perintah yang terdapat di event driven programming hanya akan dieksekusi jika memenuhi suatu event tertentu. Event yang dimaksud disini biasanya mengacu pada action dari User. Contohnya adalah tombol delete product. Perintah untuk menjalankan function delete_product hanya akan terjadi apabila kita menekan tombol untuk melakukan delete saja.

3. AJAX merupakan teknologi yang memungkinkan web untuk meminta request dan mendapatkan response tanpa harus menunggu request yang dilakukan sebelumnya terpenuhi. Ketika suatu event terjadi di website seperti misalkan kita menambahkan suatu item baru dimana kita meminta request ke server, kode-kode program django dan javascript kita sebenarnya tetap berjalan tanpa perlu menunggu response dari server. Oleh karena itu dengan AJAX, kita dapat menambahkan item baru tanpa perlu melakukan refresh jika mau meng-update halaman item terbaru

4. Fetch API merupakan API dari Javascript yang sudah built in dengan web browser, sedangkan jQuery merupakan library dari Javascript yang memiliki beragam ultility untuk web development, sehingga secara ukuran, Fetch API jelas jauh lebih ringan. Fetch API dapat memungkinkan web browser untuk langsung meminta HTTP request ke web server serta. Overall, fetch API karena dibuatnya lebih baru dibanding jQuery, ia memiliki teknologi yang lebih baru.  

5. Pertama-tama, di views.py kita buat fungsi bernama add_product_ajax yang akan mengembalikan seluruh data model Item kita dalam bentuk JSON file dan jangan lupa kita tambahkan fungsi tersebut ke urls.py. Di home.html, kita buat tag script yang nantinya akan berfungsi untuk meletakkan script-script yang kita gunakan untuk event driven programming ini. Kita buat fungsi asynchronus, async function getProducts() yang akan melakukan fetch API terhadap fungsi add_product_ajax dan melakukan parse terhadap data JSON tersebut menjadi objek Javascript. Kemudian kita buat lagi fungsi bernama asynchronus refreshProducts  untuk menampilkan seluruh Item kita, dengan membuat suatu variabel kosong bernama htmlString, kemudian dengan memanfaatkan for each pada data Item yang tadi kita ambil dengan getProducts(), kita bisa concatenate setiap Item yang ada, Item saya buat dalam bentuk card, dan kita masukkan ke variabel htmlString. Sebelumnya saya sudah membuat suatu card container, jadi untuk menampilkan card Item saya lakukan :
<div class="card-container">
    <div class='row' id="product_cards"></div>
</div>
Untuk row saya buat supaya antar item memiliki jarak sehingga tidak terlalu dempet. Setiap card item punya tombol delete, edit, increement, dan decreement. Saya membuat fungsi async function deleteItem(itemId) yang akan dipanggil ketika kita menekan tombol delete pada card item. Fungsi tersebut akan menghapus item berdasarkan id nya. Fungsi tersebut akan mem-fetch url delete_item yang sudah saya buat di tugas sebelumnya, kemudian juga dengan memanfaatkan AJAX DELETE, kita bisa menghapus item tersebut dengan memanfaatkan AJAX dan fetch API. Fungsi tersebut di akhir juga akan menjalankan fungsi refreshProduct untuk auto menampilkan card item yang terbaru. Hal yang sama juga kita terapkan pada increement dan decreement. Buat fungsi async function increementAmount(itemId) dan async function decreementAmount(itemId) yang masing-masing akan mem-fetch url increement_amount dan decreement_amount dan masing-masing akan menggunakan mthod GET milik AJAX, di akhir juga mereka akan memanggil refreshProduct untuk mendapatkan kondisi terbaru dari card Item yang ada. Untuk AJAX POST, pertama-tama kita buat fungsi add_product_by_ajax di views.py yang berfungsi membuat Item baru dan kita tambahkan di urls.py. Kemudian kita buat sebuah modal dengan id exampleModal yang akan meminta input name, amount, description, effect, dan value. Kemudian kita buat sebuah tombol yang jika ditekan, maka ia akan memunculkan modal tersebut, dengan cara data-bs-toggle="modal" data-bs-target="#exampleModal". Kemudian kita buat fungsi function addProduct() di dalam bagian script. Fungsi addProduct() ini akan mengambil semua value yang ada di modal tadi. Apabila ada value yang kosong dan user menekan submit, maka web akan menampilkan pesan error dan akan mengulang modal dari awal, begitu pun jika nilai amount atau value dimasukkan negatif. Fungsi addProduct() akan mem-fetch url fungsi add_product_by_ajax jika berhasil dan akan melakukan refreshProduct kemudian me reset kembali modal nya. Terakhir tinggal kita set jika user menekan tombol Add Product, maka fungsi addProduct() akan dipanggil. Kemudian saya juga melakukan perintah python manage.py collectstatic yang akan membuat folder berisi static files, yaitu file seperti hasil css styling, atau Javascript.

Tautan deployment : http://arya-lesmana21-tugas.pbp.cs.ui.ac.id/